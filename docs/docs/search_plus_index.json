{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction python3教程 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-21 13:50:22 "},"chapter1/section1/":{"url":"chapter1/section1/","title":"1.1 存储结构","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 字符串 2 列表 3 代码上手 存储结构 1 字符串 # 次方 -3 ** 2 # 优先级：** > - 被解析成：-(3**2) = -9 # 索引 word = 'Python' word[-1] # 'n' word[42] # 报错 # 切片，省略开始索引时，默认值为 0，省略结束索引时，默认为到字符串的结尾： word[:2] # 'Py' word[4:] # 'on' word[-2:] # 'on' word[4:42] # 'on' word[42:] # '' # 字符串不能修改 word[0] = 'J' # 报错 'J' + word[1:] # 'Jython' # len s = 'supercalifragilisticexpialidocious' len(s) # 34 2 列表 列表：用[]标注，,分隔。 可以包含不同类型的元素，但一般情况下，各个元素的类型相同： squares = [1, 4, 9, 16, 25] # 索引 squares[-1] # 25 # 切片，返回包含请求元素的新列表（浅拷贝） squares[-3:] # [9, 16, 25] letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g'] letters[2:5] = ['C', 'D', 'E'] letters # ['a', 'b', 'C', 'D', 'E', 'f', 'g'] letters[2:5] = [] letters # ['a', 'b', 'f', 'g'] # 合并 squares + [36, 49, 64, 81, 100] # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] # append() 列表结尾添加新元素 squares.append(216) # [1, 4, 9, 16, 25, 216] # len letters = ['a', 'b', 'c', 'd'] len(letters) # 4 # 嵌套列表：创建包含其他列表的列表 a = ['a', 'b', 'c'] n = [1, 2, 3] x = [a, n] x # [['a', 'b', 'c'], [1, 2, 3]] x[0] # ['a', 'b', 'c'] x[0][1] # 'b' 3 代码上手 斐波那契数列： a, b = 0, 1 while a 多重赋值：第1行和第4行，先计算=后面的结果，计算结束后再赋给前面的变量。 缩进区分各语句块。 print()默认换行，可使用end来替换换行符，同时和console.log()一般用法。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-21 10:44:48 "},"chapter1/section2/":{"url":"chapter1/section2/","title":"1.2 流程控制","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 if 2 for 2.1 for、while的else 3 range() 4 pass 5 match 5.1 case中做筛选 5.2 解包赋值与绑定变量 5.3 解构对象 5.4 如何理解 5.5 其他特性 5.5.1 case中的if 5.5.2 仅了解 流程控制 1 if if x 2 for # 创建集合 users = {'Hans': 'active', 'Éléonore': 'inactive', '景太郎': 'active'} # 在新复制的集合上遍历 for user, status in users.copy().items(): if status == 'inactive': del users[user] # 创建一个新集合来存储 active_users = {} for user, status in users.items(): if status == 'active': active_users[user] = status 2.1 for、while的else for 循环中，可迭代对象中的元素全部循环完毕，或 while 循环的条件为假时，执行同一级的else。 for n in range(2, 10): for x in range(2, n): if n % x == 0: print(n, 'equals', x, '*', n//x) break else: print(n, 'is a prime number') 3 range() 可以生成算术序列（整数），返回的是可迭代对象（iterable）。 range(num)：return [0, num) range(begin, end)：return [begin, end) range(begin, end, step)：return [begin, end) 步长为step。 # list()传入可迭代对象，生成一个列表 list(range(-10, -100, -30)) # [-10, -40, -70] # sum()传入可迭代对象，求和 sum(range(4)) # 0 + 1 + 2 + 3 = 6 4 pass pass 语句不执行任何操作。语法上需要一个语句，但程序不实际执行任何动作时，可以使用该语句。 while True: pass # Busy-wait for keyboard interrupt (Ctrl+C) # 创建了一个最小的类： class MyEmptyClass: pass # 用作函数或条件子句的占位符，让开发者聚焦更抽象的层次。 def initlog(*args): pass # Remember to implement this! 5 match 比switch更牛逼的匹配。但不需要break控制。 普通用法不必说，python多了其它种类的匹配： 5.1 case中做筛选 使用 | （或）在一个模式中可以组合多个字面值： case 401 | 403 | 404: return \"Not allowed\" 5.2 解包赋值与绑定变量 # point is an (x, y) tuple 元组 match point: case (0, 0): print(\"Origin\") case (0, y): print(f\"Y={y}\") case (x, 0): print(f\"X={x}\") case (x, y): print(f\"X={x}, Y={y}\") case _: raise ValueError(\"Not a point\") “变量名” _ 被作为 通配符 并必定会匹配成功。 第一个模式有两个字面值，可以看作是上面所示字面值模式的扩展。 但接下来的两个模式结合了一个字面值和一个变量，而变量 绑定 了一个来自目标的值（point）。 第四个模式捕获了两个值，这使得它在概念上类似于解包赋值 (x, y) = point。 5.3 解构对象 class Point: x: int y: int def where_is(point): match point: case Point(x=0, y=0): # 类名后加一个类似于构造器的参数列表，这样做可以把属性放到变量里 print(\"Origin\") case Point(x=0, y=y): print(f\"Y={y}\") case Point(x=x, y=0): print(f\"X={x}\") case Point(): print(\"Somewhere else\") case _: print(\"Not a point\") 总结： 可在 dataclass 等支持属性排序的内置类中使用位置参数。 还可在类中设置 __match_args__ 特殊属性为模式的属性定义指定位置。 如果它被设为 (\"x\", \"y\")，则以下模式均为等价的，并且都把 y 属性绑定到 var 变量： Point(1, var) Point(1, y=var) Point(x=1, y=var) Point(y=var, x=1) 5.4 如何理解 读取模式的推荐方式是将它们看做是：你会在赋值操作左侧放置的内容的扩展形式，以便理解各个变量将会被设置的值。 match 语句赋值： 只有单独的名称：例如上面的 var。 match 语句不会赋值： 带点号的名称：例如 foo.bar； 属性名称：例如上面的 x= 和 y=； 类名称：通过其后的 \"(...)\" 来识别，例如上面的 Point。 因此模式可以任意地嵌套。 例如，如果有一个由点（类实例）组成的短列表，则可使用如下方式进行匹配： match points: case []: print(\"No points\") case [Point(0, 0)]: print(\"The origin\") case [Point(x, y)]: print(f\"Single point {x}, {y}\") case [Point(0, y1), Point(0, y2)]: print(f\"Two on the Y axis at {y1}, {y2}\") case _: print(\"Something else\") 5.5 其他特性 5.5.1 case中的if match point: case Point(x, y) if x == y: print(f\"Y=X at {x}\") case Point(x, y): print(f\"Not on the diagonal\") 5.5.2 仅了解 与解包赋值类似，元组和列表模式具有完全相同的含义，并且实际上能匹配任意序列。 但它们不能匹配迭代器或字符串。 序列模式支持扩展解包操作：[x, y, *rest] 和 (x, y, *rest) 的作用类似于解包赋值。 在 * 之后的名称也可以为 _，因此，(x, y, *_) 可以匹配包含至少两个条目的序列，而不必绑定其余的条目。 映射模式：{\"bandwidth\": b, \"latency\": l} 从字典中捕获 \"bandwidth\" 和 \"latency\" 的值。与序列模式不同，额外的键会被忽略。**rest 等解包操作也支持。但 **_ 是冗余的，不允许使用。 使用 as 关键字可以捕获子模式： case (Point(x1, y1), Point(x2, y2) as p2): ... 将把输入的第二个元素捕获为 p2 (只要输入是包含两个点的序列) 大多数字面值是按相等性比较的，但是单例对象 True, False 和 None 则是按标识号比较的。 模式可以使用命名常量。 这些命名常量必须为带点号的名称以防止它们被解读为捕获变量: from enum import Enum class Color(Enum): RED = 'red' GREEN = 'green' BLUE = 'blue' color = Color(input(\"Enter your choice of 'red', 'blue' or 'green': \")) match color: case Color.RED: print(\"I see red!\") case Color.GREEN: print(\"Grass is green\") case Color.BLUE: print(\"I'm feeling the blues :(\") Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-21 12:02:50 "},"chapter1/section3/":{"url":"chapter1/section3/","title":"1.3 函数","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 定义函数 2 定义详解 2.1 默认值参数 2.2 关键字参数 2.2.1 特殊形参 2.3 特殊参数 2.3.1 特殊使用 2.4 任意实参列表 2.5 解包实参列表 2.6 Lambda 表达式 3 编码约定 函数 1 定义函数 def fib(n): \"\"\"Print a Fibonacci series up to n.\"\"\" 函数内的第一条语句是字符串时，该字符串就是文档字符串。 没有 return 语句的函数查看返回值，可使用 print() ，打印值为 None （是一个内置名称）。 2 定义详解 函数定义支持可变数量的参数。 2.1 默认值参数 定义函数，一个必选形参，两个可选形参： def ask_ok(prompt, retries=4, reminder='Please try again!'): while True: ok = input(prompt) if ok in ('y', 'ye', 'yes'): return True if ok in ('n', 'no', 'nop', 'nope'): return False retries = retries - 1 if retries 调用函数： 只给出必选实参：ask_ok('Do you really want to quit?') 给出一个可选实参：ask_ok('OK to overwrite the file?', 2) 给出所有实参：ask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!') 注意： 默认值只计算一次。 i = 5 def f(arg=i): print(arg) i = 6 f() # 5 默认值为列表、字典或类实例等可变对象时，会产生与该规则不同的结果。例如，下面的函数会累积后续调用时传递的参数： def f(a, L=[]): L.append(a) return L print(f(1)) # [1] print(f(2)) # [1, 2] print(f(3)) # [1, 2, 3] 不想在后续调用之间共享默认值时，应以如下方式编写函数： def f(a, L=None): if L is None: L = [] L.append(a) return L 2.2 关键字参数 调用函数的另一种方法称为关键字参数：f(key=value) 关键字形参也叫作命名形参。 def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'): print(\"-- This parrot wouldn't\", action, end=' ') print(\"if you put\", voltage, \"volts through it.\") print(\"-- Lovely plumage, the\", type) print(\"-- It's\", state, \"!\") # 如此调用： parrot(1000) # 1 positional argument parrot(voltage=1000) # 1 keyword argument parrot(voltage=1000000, action='VOOOOOM') # 2 keyword arguments parrot(action='VOOOOOM', voltage=1000000) # 2 keyword arguments parrot('a million', 'bereft of life', 'jump') # 3 positional arguments parrot('a thousand', state='pushing up the daisies') # 1 positional, 1 keyword 下面这些调用方式无效： parrot() # required argument missing parrot(voltage=5.0, 'dead') # non-keyword argument after a keyword argument parrot(110, voltage=220) # duplicate value for the same argument parrot(actor='John Cleese') # unknown keyword argument 总结 只要必选实参用了关键字参数，后面的可选参数必须也用关键字参数。 但如果必选实参没用关键字参数，后面可选参数可以选择性使用关键字参数， 但如果后面可选参数不使用关键字参数，则是按照位置顺序传参。 2.2.1 特殊形参 最后一个形参为 **name 形式时，接收一个字典（详见 映射类型 --- dict），该字典包含与函数中已定义形参对应之外的所有关键字参数。 **name 形参可以与 *name 形参（下下小节介绍）组合使用（name 必须在 *name 前面）， *name 形参接收一个 元组，该元组包含形参列表之外的位置参数。 例如，可以定义下面这样的函数： def cheeseshop(kind, *arguments, **keywords): print(\"-- Do you have any\", kind, \"?\") print(\"-- I'm sorry, we're all out of\", kind) for arg in arguments: print(arg) print(\"-\" * 40) for kw in keywords: print(kw, \":\", keywords[kw]) 调用该函数： cheeseshop(\"Limburger\", \"It's very runny, sir.\", \"It's really very, VERY runny, sir.\", shopkeeper=\"Michael Palin\", client=\"John Cleese\", sketch=\"Cheese Shop Sketch\") # 输出结果如下： -- Do you have any Limburger ? -- I'm sorry, we're all out of Limburger It's very runny, sir. It's really very, VERY runny, sir. ---------------------------------------- shopkeeper : Michael Palin client : John Cleese sketch : Cheese Shop Sketch 注意，关键字参数在输出结果中的顺序与调用函数时的顺序一致。 2.3 特殊参数 为了让代码易读、高效，通过在函数定义添加 / 和 * 限制参数的传递方式。 / 和 *是可选的。 def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2): ----------- ---------- ---------- | | | 位置 位置或关键字 关键字 例子： def standard_arg(arg): # 无限制 print(arg) def pos_only_arg(arg, /): # 仅限位置参数 print(arg) def kwd_only_arg(*, arg): # 仅限关键字参数 print(arg) def combined_example(arg, /, pos_or_kwd): # / 后可以是 位置或关键字 或 仅限关键字 形参。 print(pos_only, pos_or_kwd) def combined_example(pos_or_kwd, *, kwd_only): # * 前可以是 位置或关键字 或 仅限位置 形参。 print(pos_or_kwd, kwd_only) def combined_example(pos_only, /, standard, *, kwd_only): print(pos_only, standard, kwd_only) 2.3.1 特殊使用 # kwds 把 name 当作键，因此，可能与位置参数 name 产生潜在冲突： def foo(name, **kwds): return 'name' in kwds foo(1, **{'name': 2}) # 报错，不可能返回 True，因为关键字 'name' 总与第一个形参绑定，即'name' = 1, kwds中'name' = 2，1!=2 # 加上 / （仅限位置参数），此时，函数定义把 name 当作位置参数，'name' 也可以作为关键字参数的键： def foo(name, /, **kwds): return 'name' in kwds foo(1, **{'name': 2}) # true 判断为在kds是否存在有'name'这个键了。 换句话说，函数定义中的name是个形参，而return后面的name是个字符串，两者已经没有绑定在一起，因此字符串可以在 **kwds 中使用，而不产生歧义。 2.4 任意实参列表 *args 形参后的任何形式参数只能是仅限关键字参数， def concat(*args, sep=\"/\"): return sep.join(args) concat(\"earth\", \"mars\", \"venus\") # 'earth/mars/venus' concat(\"earth\", \"mars\", \"venus\", sep=\".\") # 'earth.mars.venus' 2.5 解包实参列表 *：解包列表 list(range(3, 6)) # [3, 4, 5] args = [3, 6] list(range(*args)) # [3, 4, 5] 用 * 操作符把实参从列表或元组解包成两个独立的 start 和 stop 实参： **：解包字典（集合） 即json或map格式的数据 def parrot(voltage, state='a stiff', action='voom'): print(\"-- This parrot wouldn't\", action, end=' ') print(\"if you put\", voltage, \"volts through it.\", end=' ') print(\"E's\", state, \"!\") d = {\"voltage\": \"four million\", \"state\": \"bleedin' demised\", \"action\": \"VOOM\"} parrot(**d) # This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised ! 2.6 Lambda 表达式 在语法上，匿名函数只能是单个表达式。 用 lambda 表达式返回函数： def make_incrementor(n): return lambda x: x + n f = make_incrementor(42) f(0) # 42 f(1) # 43 匿名函数用作传递的实参： pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')] pairs.sort(key=lambda pair: pair[1]) pairs # [(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')] 3 编码约定 缩进，用 4 个空格 用空行分隔函数和类，及函数内较大的代码块。 最好把注释放到单独一行。 使用文档字符串。 命名类用 UpperCamelCase， 命名函数与方法用 lowercase_with_underscores。 命名方法中第一个参数总是用 self Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-21 13:46:07 "}}