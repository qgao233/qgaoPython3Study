{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction python3教程 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-21 13:50:22 "},"chapter1/section1/":{"url":"chapter1/section1/","title":"1.1 基础序列","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 字符串 2 列表 3 代码上手 基础序列 1 字符串 # 次方 -3 ** 2 # 优先级：** > - 被解析成：-(3**2) = -9 # 索引 word = 'Python' word[-1] # 'n' word[42] # 报错 # 切片，省略开始索引时，默认值为 0，省略结束索引时，默认为到字符串的结尾： word[:2] # 'Py' word[4:] # 'on' word[-2:] # 'on' word[4:42] # 'on' word[42:] # '' # 字符串不能修改 word[0] = 'J' # 报错 'J' + word[1:] # 'Jython' # len s = 'supercalifragilisticexpialidocious' len(s) # 34 2 列表 列表：用[]标注，,分隔。 可以包含不同类型的元素，但一般情况下，各个元素的类型相同： squares = [1, 4, 9, 16, 25] # 索引 squares[-1] # 25 # 切片，返回包含请求元素的新列表（浅拷贝） squares[-3:] # [9, 16, 25] letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g'] letters[2:5] = ['C', 'D', 'E'] letters # ['a', 'b', 'C', 'D', 'E', 'f', 'g'] letters[2:5] = [] letters # ['a', 'b', 'f', 'g'] # 合并 squares + [36, 49, 64, 81, 100] # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] # append() 列表结尾添加新元素 squares.append(216) # [1, 4, 9, 16, 25, 216] # len letters = ['a', 'b', 'c', 'd'] len(letters) # 4 # 嵌套列表：创建包含其他列表的列表 a = ['a', 'b', 'c'] n = [1, 2, 3] x = [a, n] x # [['a', 'b', 'c'], [1, 2, 3]] x[0] # ['a', 'b', 'c'] x[0][1] # 'b' 3 代码上手 斐波那契数列： a, b = 0, 1 while a 多重赋值：第1行和第4行，先计算=后面的结果，计算结束后再赋给前面的变量。 缩进区分各语句块。 print()默认换行，可使用end来替换换行符，同时和console.log()一般用法。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-21 16:22:13 "},"chapter1/section2/":{"url":"chapter1/section2/","title":"1.2 流程控制","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 if 2 for 2.1 for、while的else 3 range() 4 pass 5 match 5.1 case中做筛选 5.2 解包赋值与绑定变量 5.3 解构对象 5.4 如何理解 5.5 其他特性 5.5.1 case中的if 5.5.2 仅了解 6 循环的技巧 6.1 循环字典 6.2 循环序列 7 深入条件控制 流程控制 1 if if x 2 for # 创建集合 users = {'Hans': 'active', 'Éléonore': 'inactive', '景太郎': 'active'} # 在新复制的集合上遍历 for user, status in users.copy().items(): if status == 'inactive': del users[user] # 创建一个新集合来存储 active_users = {} for user, status in users.items(): if status == 'active': active_users[user] = status 2.1 for、while的else for 循环中，可迭代对象中的元素全部循环完毕，或 while 循环的条件为假时，执行同一级的else。 for n in range(2, 10): for x in range(2, n): if n % x == 0: print(n, 'equals', x, '*', n//x) break else: print(n, 'is a prime number') 3 range() 可以生成算术序列（整数），返回的是可迭代对象（iterable）。 range(num)：return [0, num) range(begin, end)：return [begin, end) range(begin, end, step)：return [begin, end) 步长为step。 # list()传入可迭代对象，生成一个列表 list(range(-10, -100, -30)) # [-10, -40, -70] # sum()传入可迭代对象，求和 sum(range(4)) # 0 + 1 + 2 + 3 = 6 4 pass pass 语句不执行任何操作。语法上需要一个语句，但程序不实际执行任何动作时，可以使用该语句。 while True: pass # Busy-wait for keyboard interrupt (Ctrl+C) # 创建了一个最小的类： class MyEmptyClass: pass # 用作函数或条件子句的占位符，让开发者聚焦更抽象的层次。 def initlog(*args): pass # Remember to implement this! 5 match 比switch更牛逼的匹配。但不需要break控制。 普通用法不必说，python多了其它种类的匹配： 5.1 case中做筛选 使用 | （或）在一个模式中可以组合多个字面值： case 401 | 403 | 404: return \"Not allowed\" 5.2 解包赋值与绑定变量 # point is an (x, y) tuple 元组 match point: case (0, 0): print(\"Origin\") case (0, y): print(f\"Y={y}\") case (x, 0): print(f\"X={x}\") case (x, y): print(f\"X={x}, Y={y}\") case _: raise ValueError(\"Not a point\") “变量名” _ 被作为 通配符 并必定会匹配成功。 第一个模式有两个字面值，可以看作是上面所示字面值模式的扩展。 但接下来的两个模式结合了一个字面值和一个变量，而变量 绑定 了一个来自目标的值（point）。 第四个模式捕获了两个值，这使得它在概念上类似于解包赋值 (x, y) = point。 5.3 解构对象 class Point: x: int y: int def where_is(point): match point: case Point(x=0, y=0): # 类名后加一个类似于构造器的参数列表，这样做可以把属性放到变量里 print(\"Origin\") case Point(x=0, y=y): print(f\"Y={y}\") case Point(x=x, y=0): print(f\"X={x}\") case Point(): print(\"Somewhere else\") case _: print(\"Not a point\") 总结： 可在 dataclass 等支持属性排序的内置类中使用位置参数。 还可在类中设置 __match_args__ 特殊属性为模式的属性定义指定位置。 如果它被设为 (\"x\", \"y\")，则以下模式均为等价的，并且都把 y 属性绑定到 var 变量： Point(1, var) Point(1, y=var) Point(x=1, y=var) Point(y=var, x=1) 5.4 如何理解 读取模式的推荐方式是将它们看做是：你会在赋值操作左侧放置的内容的扩展形式，以便理解各个变量将会被设置的值。 match 语句赋值： 只有单独的名称：例如上面的 var。 match 语句不会赋值： 带点号的名称：例如 foo.bar； 属性名称：例如上面的 x= 和 y=； 类名称：通过其后的 \"(...)\" 来识别，例如上面的 Point。 因此模式可以任意地嵌套。 例如，如果有一个由点（类实例）组成的短列表，则可使用如下方式进行匹配： match points: case []: print(\"No points\") case [Point(0, 0)]: print(\"The origin\") case [Point(x, y)]: print(f\"Single point {x}, {y}\") case [Point(0, y1), Point(0, y2)]: print(f\"Two on the Y axis at {y1}, {y2}\") case _: print(\"Something else\") 5.5 其他特性 5.5.1 case中的if match point: case Point(x, y) if x == y: print(f\"Y=X at {x}\") case Point(x, y): print(f\"Not on the diagonal\") 5.5.2 仅了解 与解包赋值类似，元组和列表模式具有完全相同的含义，并且实际上能匹配任意序列。 但它们不能匹配迭代器或字符串。 序列模式支持扩展解包操作：[x, y, *rest] 和 (x, y, *rest) 的作用类似于解包赋值。 在 * 之后的名称也可以为 _，因此，(x, y, *_) 可以匹配包含至少两个条目的序列，而不必绑定其余的条目。 映射模式：{\"bandwidth\": b, \"latency\": l} 从字典中捕获 \"bandwidth\" 和 \"latency\" 的值。与序列模式不同，额外的键会被忽略。**rest 等解包操作也支持。但 **_ 是冗余的，不允许使用。 使用 as 关键字可以捕获子模式： case (Point(x1, y1), Point(x2, y2) as p2): ... 将把输入的第二个元素捕获为 p2 (只要输入是包含两个点的序列) 大多数字面值是按相等性比较的，但是单例对象 True, False 和 None 则是按标识号比较的。 模式可以使用命名常量。 这些命名常量必须为带点号的名称以防止它们被解读为捕获变量: from enum import Enum class Color(Enum): RED = 'red' GREEN = 'green' BLUE = 'blue' color = Color(input(\"Enter your choice of 'red', 'blue' or 'green': \")) match color: case Color.RED: print(\"I see red!\") case Color.GREEN: print(\"Grass is green\") case Color.BLUE: print(\"I'm feeling the blues :(\") 6 循环的技巧 6.1 循环字典 在字典中循环时，用 items() 方法可同时取出键和对应的值： knights = {'gallahad': 'the pure', 'robin': 'the brave'} for k, v in knights.items(): print(k, v) # gallahad the pure # robin the brave 6.2 循环序列 在序列中循环时，用 enumerate() 函数可以同时取出位置索引和对应的值： >>> >>> for i, v in enumerate(['tic', 'tac', 'toe']): ... print(i, v) ... 0 tic 1 tac 2 toe 同时循环两个或多个序列时，用 zip() 函数可以将其内的元素一一匹配： >>> >>> questions = ['name', 'quest', 'favorite color'] >>> answers = ['lancelot', 'the holy grail', 'blue'] >>> for q, a in zip(questions, answers): ... print('What is your {0}? It is {1}.'.format(q, a)) ... What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. 逆向循环序列时，先正向定位序列，然后调用 reversed() 函数： >>> >>> for i in reversed(range(1, 10, 2)): ... print(i) ... 9 7 5 3 1 按指定顺序循环序列，可以用 sorted() 函数，在不改动原序列的基础上，返回一个重新的序列： >>> >>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana'] >>> for i in sorted(basket): ... print(i) ... apple apple banana orange orange pear 使用 set() 去除序列中的重复元素。使用 sorted() 加 set() 则按排序后的顺序，循环遍历序列中的唯一元素： >>> >>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana'] >>> for f in sorted(set(basket)): ... print(f) ... apple banana orange pear 一般来说，在循环中修改列表的内容时，创建新列表比较简单，且安全： >>> >>> import math >>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8] >>> filtered_data = [] >>> for value in raw_data: ... if not math.isnan(value): ... filtered_data.append(value) ... >>> filtered_data [56.2, 51.7, 55.3, 52.5, 47.8] 7 深入条件控制 比较运算符 in 和 not in 用于执行确定一个值是否存在（或不存在）于某个容器中的成员检测。 运算符 is 和 is not 用于比较两个对象是否是同一个对象。 所有比较运算符的优先级都一样，且低于任何数值运算符。 比较操作支持链式操作。例如，a 校验 a 是否小于 b，且 b 是否等于 c。 比较操作可以用布尔运算符 and 和 or 组合，并且，比较操作（或其他布尔运算）的结果都可以用 not 取反。 这些操作符的优先级低于比较操作符；not 的优先级最高， or 的优先级最低，因此，A and not B or C 等价于 (A and (not B)) or C。与其他运算符操作一样，此处也可以用圆括号表示想要的组合。 布尔运算符 and 和 or 也称为 短路 运算符：其参数从左至右解析，一旦可以确定结果，解析就会停止。例如，如果 A 和 C 为真，B 为假，那么 A and B and C 不会解析 C。用作普通值而不是布尔值时，短路操作符返回的值通常是最后一个变量。 还可以把比较操作或逻辑表达式的结果赋值给变量，例如： >>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance' >>> non_null = string1 or string2 or string3 >>> non_null 'Trondheim' 注意，Python 与 C 不同，在表达式内部赋值必须显式使用 海象运算符 :=。 这避免了 C 程序中常见的问题：要在表达式中写 == 时，却写成了 =。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-21 17:16:42 "},"chapter1/section3/":{"url":"chapter1/section3/","title":"1.3 函数","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 定义函数 2 定义详解 2.1 默认值参数 2.2 关键字参数 2.2.1 特殊形参 2.3 特殊参数 2.3.1 特殊使用 2.4 任意实参列表 2.5 解包实参列表 2.6 Lambda 表达式 3 编码约定 函数 1 定义函数 def fib(n): \"\"\"Print a Fibonacci series up to n.\"\"\" 函数内的第一条语句是字符串时，该字符串就是文档字符串。 没有 return 语句的函数查看返回值，可使用 print() ，打印值为 None （是一个内置名称）。 2 定义详解 函数定义支持可变数量的参数。 2.1 默认值参数 定义函数，一个必选形参，两个可选形参： def ask_ok(prompt, retries=4, reminder='Please try again!'): while True: ok = input(prompt) if ok in ('y', 'ye', 'yes'): return True if ok in ('n', 'no', 'nop', 'nope'): return False retries = retries - 1 if retries 调用函数： 只给出必选实参：ask_ok('Do you really want to quit?') 给出一个可选实参：ask_ok('OK to overwrite the file?', 2) 给出所有实参：ask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!') 注意： 默认值只计算一次。 i = 5 def f(arg=i): print(arg) i = 6 f() # 5 默认值为列表、字典或类实例等可变对象时，会产生与该规则不同的结果。例如，下面的函数会累积后续调用时传递的参数： def f(a, L=[]): L.append(a) return L print(f(1)) # [1] print(f(2)) # [1, 2] print(f(3)) # [1, 2, 3] 不想在后续调用之间共享默认值时，应以如下方式编写函数： def f(a, L=None): if L is None: L = [] L.append(a) return L 2.2 关键字参数 调用函数的另一种方法称为关键字参数：f(key=value) 关键字形参也叫作命名形参。 def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'): print(\"-- This parrot wouldn't\", action, end=' ') print(\"if you put\", voltage, \"volts through it.\") print(\"-- Lovely plumage, the\", type) print(\"-- It's\", state, \"!\") # 如此调用： parrot(1000) # 1 positional argument parrot(voltage=1000) # 1 keyword argument parrot(voltage=1000000, action='VOOOOOM') # 2 keyword arguments parrot(action='VOOOOOM', voltage=1000000) # 2 keyword arguments parrot('a million', 'bereft of life', 'jump') # 3 positional arguments parrot('a thousand', state='pushing up the daisies') # 1 positional, 1 keyword 下面这些调用方式无效： parrot() # required argument missing parrot(voltage=5.0, 'dead') # non-keyword argument after a keyword argument parrot(110, voltage=220) # duplicate value for the same argument parrot(actor='John Cleese') # unknown keyword argument 总结 只要必选实参用了关键字参数，后面的可选参数必须也用关键字参数。 但如果必选实参没用关键字参数，后面可选参数可以选择性使用关键字参数， 但如果后面可选参数不使用关键字参数，则是按照位置顺序传参。 2.2.1 特殊形参 最后一个形参为 **name 形式时，接收一个字典（详见 映射类型 --- dict），该字典包含与函数中已定义形参对应之外的所有关键字参数。 **name 形参可以与 *name 形参（下下小节介绍）组合使用（name 必须在 *name 前面）， *name 形参接收一个 元组，该元组包含形参列表之外的位置参数。 例如，可以定义下面这样的函数： def cheeseshop(kind, *arguments, **keywords): print(\"-- Do you have any\", kind, \"?\") print(\"-- I'm sorry, we're all out of\", kind) for arg in arguments: print(arg) print(\"-\" * 40) for kw in keywords: print(kw, \":\", keywords[kw]) 调用该函数： cheeseshop(\"Limburger\", \"It's very runny, sir.\", \"It's really very, VERY runny, sir.\", shopkeeper=\"Michael Palin\", client=\"John Cleese\", sketch=\"Cheese Shop Sketch\") # 输出结果如下： -- Do you have any Limburger ? -- I'm sorry, we're all out of Limburger It's very runny, sir. It's really very, VERY runny, sir. ---------------------------------------- shopkeeper : Michael Palin client : John Cleese sketch : Cheese Shop Sketch 注意，关键字参数在输出结果中的顺序与调用函数时的顺序一致。 2.3 特殊参数 为了让代码易读、高效，通过在函数定义添加 / 和 * 限制参数的传递方式。 / 和 *是可选的。 def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2): ----------- ---------- ---------- | | | 位置 位置或关键字 关键字 例子： def standard_arg(arg): # 无限制 print(arg) def pos_only_arg(arg, /): # 仅限位置参数 print(arg) def kwd_only_arg(*, arg): # 仅限关键字参数 print(arg) def combined_example(arg, /, pos_or_kwd): # / 后可以是 位置或关键字 或 仅限关键字 形参。 print(pos_only, pos_or_kwd) def combined_example(pos_or_kwd, *, kwd_only): # * 前可以是 位置或关键字 或 仅限位置 形参。 print(pos_or_kwd, kwd_only) def combined_example(pos_only, /, standard, *, kwd_only): print(pos_only, standard, kwd_only) 2.3.1 特殊使用 # kwds 把 name 当作键，因此，可能与位置参数 name 产生潜在冲突： def foo(name, **kwds): return 'name' in kwds foo(1, **{'name': 2}) # 报错，不可能返回 True，因为关键字 'name' 总与第一个形参绑定，即'name' = 1, kwds中'name' = 2，1!=2 # 加上 / （仅限位置参数），此时，函数定义把 name 当作位置参数，'name' 也可以作为关键字参数的键： def foo(name, /, **kwds): return 'name' in kwds foo(1, **{'name': 2}) # true 判断为在kds是否存在有'name'这个键了。 换句话说，函数定义中的name是个形参，而return后面的name是个字符串，两者已经没有绑定在一起，因此字符串可以在 **kwds 中使用，而不产生歧义。 2.4 任意实参列表 *args 形参后的任何形式参数只能是仅限关键字参数， def concat(*args, sep=\"/\"): return sep.join(args) concat(\"earth\", \"mars\", \"venus\") # 'earth/mars/venus' concat(\"earth\", \"mars\", \"venus\", sep=\".\") # 'earth.mars.venus' 2.5 解包实参列表 *：解包列表 list(range(3, 6)) # [3, 4, 5] args = [3, 6] list(range(*args)) # [3, 4, 5] 用 * 操作符把实参从列表或元组解包成两个独立的 start 和 stop 实参： **：解包字典 即json或map格式的数据 def parrot(voltage, state='a stiff', action='voom'): print(\"-- This parrot wouldn't\", action, end=' ') print(\"if you put\", voltage, \"volts through it.\", end=' ') print(\"E's\", state, \"!\") d = {\"voltage\": \"four million\", \"state\": \"bleedin' demised\", \"action\": \"VOOM\"} parrot(**d) # This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised ! 2.6 Lambda 表达式 在语法上，匿名函数只能是单个表达式。 用 lambda 表达式返回函数： def make_incrementor(n): return lambda x: x + n f = make_incrementor(42) f(0) # 42 f(1) # 43 匿名函数用作传递的实参： pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')] pairs.sort(key=lambda pair: pair[1]) pairs # [(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')] 3 编码约定 缩进，用 4 个空格 用空行分隔函数和类，及函数内较大的代码块。 最好把注释放到单独一行。 使用文档字符串。 命名类用 UpperCamelCase， 命名变量或函数与方法时用 lowercase_with_underscores。 命名方法中第一个参数总是用 self Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-25 17:20:59 "},"chapter1/section4/":{"url":"chapter1/section4/","title":"1.4 数据结构","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 列表 1.1 列表推导式 1.2 del命令 2 序列：元组 2.1 列表与元组的区别 2.2 创建0元组和1元组 2.3 元组打包和序列解包 3 集合 3.1 集合推导式 4 字典 4.1 dict() 4.2 字典推导式 5 序列之间的比较 数据结构 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）； 可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。 1 列表 方法 解释 append(x) 在列表末尾添加一个元素，相当于 a[len(a):] = [x] 。 extend(iterable) 用可迭代对象的元素扩展列表。相当于 a[len(a):] = iterable 。 insert(i, x) 在指定位置插入元素。第一个参数是插入元素的索引，因此，a.insert(0, x) 在列表开头插入元素， a.insert(len(a), x) 等同于 a.append(x) 。 remove(x) 从列表中删除第一个值为 x 的元素。未找到指定元素时，触发 ValueError 异常。 pop([i]) 删除列表中指定位置的元素，并返回被删除的元素。未指定位置时，a.pop() 删除并返回列表的最后一个元素。（方法签名中 i 两边的方括号表示该参数是可选的，不是要求输入方括号。这种表示法常见于 Python 参考库）。 clear() 删除列表里的所有元素，相当于 del a[:] 。 index(x[, start[, end]]) 返回列表中第一个值为 x 的元素的零基索引。未找到指定元素时，触发 ValueError 异常。可选参数 start 和 end 是切片符号，用于将搜索限制为列表的特定子序列。返回的索引是相对于整个序列的开始计算的，而不是 start 参数。 count(x) 返回列表中元素 x 出现的次数。 sort(*, key=None, reverse=False) 就地排序列表中的元素（要了解自定义排序参数，详见 sorted()）。 reverse() 翻转列表中的元素。 copy() 返回列表的浅拷贝。相当于 a[:] 。 fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana'] >>> fruits.count('apple') # 2 >>> fruits.count('tangerine') # 0 >>> fruits.index('banana') # 3 >>> fruits.index('banana', 4) # 6 >>> fruits.reverse() >>> fruits # ['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange'] >>> fruits.append('grape') >>> fruits # ['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape'] >>> fruits.sort() >>> fruits # ['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear'] >>> fruits.pop() # 'pear' 1.1 列表推导式 常见的用法为， 对序列或可迭代对象中的每个元素应用某种操作， 用生成的结果创建新的列表； 或用满足特定条件的元素创建子序列。 这种写法更简洁、易读。（？？？） 列表推导式的[]内包含以下内容： 一个表达式，后面是零个或多个 for 或 if 子句。 结果是由表达式依据 for 和 if 子句求值计算而得出一个新列表。 例1，创建平方值的列表： # 列表推导式 squares = [x**2 for x in range(10)] #等价于 squares = [] for x in range(10): squares.append(x**2) 例2，将两个列表中不相等的元素组合起来： [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y] #等价于 combs = [] for x in [1,2,3]: for y in [3,1,4]: if x != y: combs.append((x, y)) 例3，转置行列（嵌套列表推导式）： matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], ] [[row[i] for row in matrix] for i in range(4)] # [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]] # 等价于 transposed = [] for i in range(4): transposed.append([row[i] for row in matrix]) # 实际应用中，最好用内置函数替代复杂的流程语句。 list(zip(*matrix)) 1.2 del命令 del 语句按索引，而不是值从列表中移除元素。 >>> a = [-1, 1, 66.25, 333, 333, 1234.5] >>> del a[0] >>> a # [1, 66.25, 333, 333, 1234.5] >>> del a[2:4] >>> a # [1, 66.25, 1234.5] >>> del a[:] >>> a # [] >>> del a # 删除整个变量，再引用 a 就会报错（直到为它赋与另一个值） 2 序列：元组 序列： 字符串 列表 元组 元组由多个用,隔开的值组成， >>> t = 12345, 54321, 'hello!' >>> t[0] # 12345 >>> t # (12345, 54321, 'hello!') >>> u = t, (1, 2, 3, 4, 5) >>> u # ((12345, 54321, 'hello!'), (1, 2, 3, 4, 5)) >>> v = ([1, 2, 3], [3, 2, 1]) >>> v # ([1, 2, 3], [3, 2, 1]) 输入时，圆括号可有可无，不过经常是必须的（如果元组是更大的表达式的一部分）。 输出时，元组都要由圆括号标注，这样才能正确地解释嵌套元组。 不允许为元组中的单个元素赋值，当然，可以创建含列表等可变对象的元组。 2.1 列表与元组的区别 列表： mutable （可变的），列表元素一般为同质类型，可迭代访问。 元组： immutable （不可变的），一般可包含异质元素序列，通过解包（见本节下文）或索引访问（如果是 namedtuples，可以属性访问）。 因此，元组与列表虽然很像，但使用场景不同，用途也不同。 2.2 创建0元组和1元组 >>> empty = () # 0元组 >>> singleton = 'hello', # 1元组，结尾有个逗号 >>> len(empty) # 0 >>> len(singleton) # 1 >>> singleton # ('hello',) 2.3 元组打包和序列解包 t = 12345, 54321, 'hello!' # 元组打包 x, y, z = t # 序列解包，左侧变量与右侧序列元素的数量应相等。 多重赋值其实只是元组打包和序列解包的组合。 3 集合 集合是由不重复元素组成的无序容器。基本用法包括： 成员检测、 消除重复元素。 集合对象支持合集、交集、差集、对称差分等数学运算。 创建集合只能用 set() ！ 虽然{}也可以，但它不能用在创建空集合的时候，因为那是创建空字典，因此创建集合统一使用set()。 >>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'} 或者 >>> basket = set(('apple', 'orange', 'apple', 'pear', 'orange', 'banana')) #只能传入一个参数，可以是list,tuple等 类型 >>> print(basket) # {'orange', 'banana', 'pear', 'apple'} >>> 'orange' in basket # True >>> 'crabgrass' in basket # False >>> # Demonstrate set operations on unique letters from two words ... >>> a = set('abracadabra') >>> b = set('alacazam') >>> a # {'a', 'r', 'b', 'c', 'd'} >>> a - b # 差集 {'r', 'd', 'b'} >>> a | b # 并集 {'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'} >>> a & b # 交集 {'a', 'c'} >>> a ^ b # 反交集 {'r', 'd', 'b', 'm', 'z', 'l'} 3.1 集合推导式 >>> a = {x for x in 'abracadabra' if x not in 'abc'} >>> a # {'r', 'd'} 4 字典 其他语言可能把字典称为 联合内存 或 联合数组。其实就是map。 与以连续整数为索引的序列不同，字典以 关键字 为索引，关键字通常是： 字符串， 或数字， 或只包含字符串、数字、元组的元组。 也可以是其他任意不可变类型。 但如果元组直接或间接地包含了可变对象，就不能用作关键字。 创建字典： 空的 {} 用于创建空字典。 在{}里输入,分隔的键值对，这也是字典的输出方式。 使用字典： 用 del 可以删除键值对。 对字典执行 list(d) 操作，返回该字典中所有键的列表，按插入次序排列 排序，请使用 sorted(d)。 检查字典里是否存在某个键，使用关键字 in。 例子： >>> tel = {'jack': 4098, 'sape': 4139} >>> tel['guido'] = 4127 >>> tel # {'jack': 4098, 'sape': 4139, 'guido': 4127} >>> tel['jack'] # 4098 >>> del tel['sape'] >>> tel['irv'] = 4127 >>> tel # {'jack': 4098, 'guido': 4127, 'irv': 4127} >>> list(tel) # ['jack', 'guido', 'irv'] >>> sorted(tel) # ['guido', 'irv', 'jack'] >>> 'guido' in tel # True >>> 'jack' not in tel # False 4.1 dict() dict() 构造函数可以直接用键值对序列创建字典： >>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)]) # {'sape': 4139, 'guido': 4127, 'jack': 4098} 关键字是比较简单的字符串时，直接用关键字参数指定键值对更便捷： >>> dict(sape=4139, guido=4127, jack=4098) # {'sape': 4139, 'guido': 4127, 'jack': 4098} 4.2 字典推导式 >>> {x: x**2 for x in (2, 4, 6)} # {2: 4, 4: 16, 6: 36} 5 序列之间的比较 序列对象可以与相同序列类型的其他对象比较。这种比较使用 字典式 顺序： 首先，比较前两个对应元素，如果不相等，则可确定比较结果；如果相等，则比较之后的两个元素，以此类推，直到其中一个序列结束。 如果要比较的两个元素本身是相同类型的序列，则递归地执行字典式顺序比较。 如果两个序列中所有的对应元素都相等，则两个序列相等。 如果一个序列是另一个的初始子序列，则较短的序列可被视为较小（较少）的序列。 对于字符串来说，字典式顺序使用 Unicode 码位序号排序单个字符。下面列出了一些比较相同类型序列的例子： (1, 2, 3) 注意，对不同类型的对象来说，只要待比较的对象提供了合适的比较方法，就可以使用 进行比较。例如，混合数值类型通过数值进行比较，所以，0 等于 0.0，等等。否则，解释器不会随便给出一个对比结果，而是触发 TypeError 异常。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-21 17:20:12 "},"chapter2/":{"url":"chapter2/","title":"2 面向对象","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 Python 命名空间和作用域 1.1 命名空间 1.2 作用域 1.3 作用域和命名空间示例 2 类 2.1 类定义 2.2 类对象 2.2.1 属性引用 2.2.2 实例化 2.3 实例对象 2.4 方法对象 2.5 类和实例变量 3 继承 3.1 多重继承 4 私有变量 5 看不懂的补充系列 6 迭代器 6.1 自定义迭代器 6.2 生成器 6.3 生成器表达式 面向对象 1 Python 命名空间和作用域 1.1 命名空间 namespace （命名空间）是映射到对象的名称。 现在，大多数命名空间都使用 Python 字典实现， 命名空间的几个常见示例： abs() 函数、内置异常等的内置函数集合； 模块中的全局名称； 函数调用中的局部名称； 对象的属性集合。 不同命名空间中的名称之间绝对没有关系； 例如，两个不同的模块都可以定义 maximize 函数，且不会造成混淆。用户使用函数时必须要在函数名前面附加上模块名。 表达式 modname.funcname 中，modname 是模块对象，funcname 是模块属性。 模块属性和模块中定义的全局名称之间存在直接的映射：它们共享相同的命名空间！ 属性可以是只读或者可写的。 如果可写，则可对属性赋值。如使用 modname.the_answer = 42 。而del 语句可以删除可写属性。 例如， del modname.the_answer 会删除 modname 对象中的 the_answer 属性。 命名空间是在不同时刻创建的，且拥有不同的生命周期。 内置名称的命名空间是在 Python 解释器启动时创建的，永远不会被删除。 模块的全局命名空间在读取模块定义时创建；通常，模块的命名空间也会持续到解释器退出。从脚本文件读取或交互式读取的，由解释器顶层调用执行的语句是 __main__ 模块调用的一部分，也拥有自己的全局命名空间。内置名称实际上也在模块里，即 builtins 。 函数的本地命名空间在调用该函数时创建，并在函数返回或抛出不在函数内部处理的错误时被删除。 （实际上，用“遗忘”来描述实际发生的情况会更好一些。） 当然，每次递归调用都会有自己的本地命名空间。 1.2 作用域 作用域 是在命名空间中可直接访问的 Python 程序的文本区域。 “可直接访问” 的意思是，对名称的非限定引用会在命名空间中查找名称。 作用域虽然是静态确定的，但会被动态使用。执行期间的任何时刻，都会有 3 或 4 个命名空间可被直接访问的嵌套作用域： 最内层作用域，包含局部名称，并首先在其中进行搜索 封闭函数的作用域，包含非局部名称和非全局名称，从最近的封闭作用域开始搜索 倒数第二个作用域，包含当前模块的全局名称 最外层的作用域，包含内置名称的命名空间，最后搜索 绑定变量到不同作用域： 使用 global 语句把该变量声明为全局变量，则所有引用和赋值将直接指向包含该模块的全局名称的中间作用域。 使用 nonlocal 语句把该变量声明为非局部变量，重新绑定在最内层作用域以外找到的变量。 未声明为非局部变量的变量是只读的，（写入只读变量会在最内层作用域中创建一个 新的 局部变量，而同名的外部变量保持不变。） 通常， 当前局部作用域将（按字面文本）引用当前函数的局部名称作为局部命名空间。 在函数之外，局部作用域引用与全局作用域一致的命名空间：模块的命名空间。 类定义会在局部命名空间内再放置另一个命名空间。 划重点，作用域是按字面文本确定的：无论该函数从什么地方或以什么别名被调用，模块内定义的函数的全局作用域就是该模块的命名空间。另一方面，实际的名称搜索是在运行时动态完成的。但是，Python 正在朝着“编译时静态名称解析”的方向发展，因此不要过于依赖动态名称解析！（局部变量已经是被静态确定了。） Python 有一个特殊规定。如果不存在生效的 global 或 nonlocal 语句，则对名称的赋值总是会进入最内层作用域。赋值不会复制数据，只是将名称绑定到对象。删除也是如此：语句 del x 从局部作用域引用的命名空间中移除对 x 的绑定。所有引入新名称的操作都是使用局部作用域：尤其是 import 语句和函数定义会在局部作用域中绑定模块或函数名称。 global 语句用于表明特定变量在全局作用域里，并应在全局作用域中重新绑定； nonlocal 语句表明特定变量在外层作用域中，并应在外层作用域中重新绑定。 1.3 作用域和命名空间示例 def scope_test(): def do_local(): spam = \"local spam\" def do_nonlocal(): nonlocal spam spam = \"nonlocal spam\" def do_global(): global spam spam = \"global spam\" spam = \"test spam\" do_local() # 不会改变 scope_test 对 spam 的绑定 print(\"After local assignment:\", spam) # test spam do_nonlocal() # 改变 scope_test 对 spam 的绑定 print(\"After nonlocal assignment:\", spam) # nonlocal spam do_global() # 改变模块层级的绑定，而且，global 赋值前没有 spam 的绑定。 print(\"After global assignment:\", spam) # nonlocal spam scope_test() print(\"In global scope:\", spam) # global spam 2 类 2.1 类定义 class ClassName: ... 当进入类定义时，将创建一个新的命名空间，并将其用作局部作用域 --- 因此，所有对局部变量的赋值都是在这个新命名空间之内。 特别的，函数定义会绑定到这里的新函数名称。 当（从结尾处）正常离开类定义时，将创建一个 类对象。 这基本上是一个包围在类定义所创建命名空间内容周围的包装器；离开范围后，原始的（在进入类定义之前起作用的）局部作用域将重新生效，类对象将在这里被绑定到类定义头所给出的类名称 (在这个示例中为 ClassName)。 2.2 类对象 注意：类对象不是实例！ 类对象支持两种操作： 属性引用：类的属性引用参考java的静态属性的引用 实例化 2.2.1 属性引用 有效的属性名称是类对象被创建时存在于类命名空间中的所有名称。 因此，如果类定义是这样的: class MyClass: \"\"\"A simple example class\"\"\" i = 12345 def f(self): return 'hello world' 那么 MyClass.i 和 MyClass.f 就是有效的属性引用，将分别返回一个整数和一个函数对象。 类属性也可以被赋值，因此可以通过赋值来更改 MyClass.i 的值。 __doc__ 也是一个有效的属性，MyClass.__doc__ 将返回所属类的文档字符串: \"A simple example class\"。 2.2.2 实例化 x = MyClass() 实例化时会去调用构造方法。 许多类喜欢创建带有特定初始状态的自定义实例。 为此类定义可能包含一个名为 __init__() 的特殊方法（构造方法），就像这样: def __init__(self): self.data = [] 带参数的构造方法： >>> class Complex: ... def __init__(self, realpart, imagpart): ... self.r = realpart ... self.i = imagpart ... >>> x = Complex(3.0, -4.5) >>> x.r, x.i (3.0, -4.5) 2.3 实例对象 对象的属性引用有两种有效的属性名称： 数据属性：实例变量 方法 数据属性不需要声明；像局部变量一样，它们将在第一次被赋值时产生。 例如，如果 x 是上面创建的 MyClass 的实例，则以下代码段将打印数值 16，且不保留任何追踪信息: x.counter = 1 while x.counter 方法： 实例对象的有效方法名称依赖于其所属的类。 根据定义，一个类中所有是函数对象的属性都是定义了其实例的相应方法。 意思就是，在从类对象的角度看是函数的定义，而从实例对象的角度看是可以被实例调用的方法。 举例： 因为 MyClass.f 是一个函数，x.f 是有效的方法引用。 因为 MyClass.i 不是函数，而 x.i 不是方法。 但是 x.f 与 MyClass.f 并不是一回事 --- x.f是一个 方法对象，不是函数对象。 我服了，贼简单的定义，为什么官网能说得那么绕。看到这里的小朋友，如果不信，可以去官网瞅瞅所有上面的这一段，简直坑爹... 而你们现在看到的都是我中文转中文又翻译了一遍的东西。 2.4 方法对象 通常，方法在绑定后可以如此被调用: x.f() 在 MyClass 示例中，这将返回字符串 'hello world'。 但是，x.f 是一个方法对象，它可以被保存起来以后再调用。 例如: xf = x.f while True: print(xf()) 上面调用 x.f() 时并没有带参数，而原f的定义为def f(self)，其实，调用 x.f() 其实就相当于 MyClass.f(x)。 方法的特殊之处就在于实例对象会作为函数的第一个参数被传入。 总之，调用一个具有 n 个参数的方法就相当于调用再多一个参数的对应函数，这个参数值为方法所属实例对象，位置在其他参数之前。 2.5 类和实例变量 class Dog: kind = 'canine' # 被所有实例共享的类变量 def __init__(self, name): self.name = name # 实例变量 >>> d = Dog('Fido') >>> e = Dog('Buddy') >>> d.kind # shared by all dogs 'canine' >>> e.kind # shared by all dogs 'canine' >>> d.name # unique to d 'Fido' >>> e.name # unique to e 'Buddy' 实际上，在 Python 中没有任何东西能强制隐藏数据（像java的private） --- 它是完全基于约定的。 每个值都是一个对象，因此具有 类 （也称为 类型），并存储为 object.__class__ 。 3 继承 派生类定义的语法如下所示: class DerivedClassName(BaseClassName): ... 名称 BaseClassName 必须定义于包含派生类定义的作用域中。 也允许用其他任意表达式代替基类名称所在的位置。 例如，当基类定义在另一个模块中的时候: class DerivedClassName(modname.BaseClassName): 如果调用同一基类中定义的另一方法，因为派生类重写了该方法，则会调用重写后的方法。 如果想直接调用基类中实现的方法，则可以这样调用 BaseClassName.methodname(self, arguments)。 有时这对客户端来说也是有用的。 （请注意仅当此基类可在全局作用域中以 BaseClassName 的名称被访问时方可使用此方式。） Python有两个内置函数可被用于检查继承机制： isinstance() ：检查一个实例的类型: isinstance(obj, int) 仅会在 obj.__class__ 为 int 或某个派生自 int 的类时为 True。 issubclass() ：检查类的继承关系: issubclass(bool, int) 为 True，因为 bool 是 int 的子类。 但是，issubclass(float, int) 为 False，因为 float 不是 int 的子类。 3.1 多重继承 带有多个基类的类定义语句如下所示: class DerivedClassName(Base1, Base2, Base3): 在最简单的情况下，你可以认为搜索从父类所继承属性的操作是深度优先、从左至右的，当层次结构中存在重叠时不会在同一个类中搜索两次。 因此，如果某一属性在 DerivedClassName 中未找到，则会到 Base1 中搜索它，然后（递归地）到 Base1 的基类中搜索，如果在那里未找到，再到 Base2 中搜索，依此类推。 实际情况，动态改变顺序是有必要的，因为所有多重继承的情况都会显示出一个或更多的菱形关联（即至少有一个父类可通过多条路径被最底层类所访问）。 4 私有变量 由于存在对于类私有成员的有效使用场景（例如避免名称与子类所定义的名称相冲突），python有个机制： 名称改写：任何形式为 __spam 的标识符（至少带有两个前缀下划线，至多一个后缀下划线）的文本将被替换为 _classname__spam，其中 classname 为去除了前缀下划线的当前类名称。 这种改写不考虑标识符的句法位置，只要它出现在类定义内部就会进行。 class Mapping: def __init__(self, iterable): self.items_list = [] self.__update(iterable) def update(self, iterable): for item in iterable: self.items_list.append(item) __update = update # __update被改写为_Mapping__update class MappingSubclass(Mapping): __update = 0 # __update被改写为_MappingSubclass__update def update(self, keys, values): # provides new signature for update() # but does not break __init__() for item in zip(keys, values): self.items_list.append(item) 请注意传递给 exec() 或 eval() 的代码不会将发起调用类的类名视作当前类；这类似于 global 语句的效果，因此这种效果仅限于同时经过字节码编译的代码。 同样的限制也适用于 getattr(), setattr() 和 delattr()，以及对于 __dict__ 的直接引用。 5 看不懂的补充系列 有时会需要使用类似于 Pascal 的“record”或 C 的“struct”这样的数据类型，将一些命名数据项捆绑在一起。 这种情况适合定义一个空类: class Employee: pass john = Employee() # Create an empty employee record # Fill the fields of the record john.name = 'John Doe' john.dept = 'computer lab' john.salary = 1000 一段需要特定抽象数据类型的 Python 代码往往可以被传入一个模拟了该数据类型的方法的类作为替代。 例如，如果你有一个基于文件对象来格式化某些数据的函数，你可以定义一个带有 read() 和 readline() 方法从字符串缓存获取数据的类，并将其作为参数传入。 实例方法对象也具有属性: m.__self__ 就是带有 m() 方法的实例对象，而 m.__func__ 则是该方法所对应的函数对象。 6 迭代器 到目前为止，您可能已经注意到大多数容器对象都可以使用 for 语句: for element in [1, 2, 3]: print(element) for element in (1, 2, 3): print(element) for key in {'one':1, 'two':2}: print(key) for char in \"123\": print(char) for line in open(\"myfile.txt\"): print(line, end='') 迭代原理： 在幕后，for 语句会在容器对象上调用 iter()。 该函数返回一个定义了 __next__() 方法的迭代器对象，此方法将逐一访问容器中的元素。 当元素用尽时，__next__() 将引发 StopIteration 异常来通知终止 for 循环。 你可以使用 next() 内置函数来调用 __next__() 方法；这个例子显示了它的运作方式: >>> s = 'abc' >>> it = iter(s) >>> it >>> next(it) 'a' >>> next(it) 'b' >>> next(it) 'c' >>> next(it) Traceback (most recent call last): File \"\", line 1, in next(it) StopIteration 6.1 自定义迭代器 看过迭代器协议的幕后机制，给你的类添加迭代器行为就很容易了。 定义一个 __iter__() 方法来返回一个带有 __next__() 方法的对象。 如果类已定义了 __next__()，则 __iter__() 可以简单地返回 self: class Reverse: \"\"\"Iterator for looping over a sequence backwards.\"\"\" def __init__(self, data): self.data = data self.index = len(data) def __iter__(self): return self def __next__(self): if self.index == 0: raise StopIteration self.index = self.index - 1 return self.data[self.index] >>> >>> rev = Reverse('spam') >>> iter(rev) >>> for char in rev: ... print(char) ... m a p s 6.2 生成器 一个用于创建迭代器的简单而强大的工具。 它们的写法类似于标准的函数，但当它们要返回数据时会使用 yield 语句。 每次在生成器上调用 next() 时，它会从上次离开的位置恢复执行（它会记住上次执行语句时的所有数据值）。 一个显示如何非常容易地创建生成器的示例如下: def reverse(data): for index in range(len(data)-1, -1, -1): yield data[index] >>> >>> for char in reverse('golf'): ... print(char) ... f l o g 可以用生成器来完成的操作同样可以用前一节所描述的基于类的迭代器来完成。 但生成器的写法更为紧凑，因为它会自动创建 __iter__() 和 __next__() 方法。 另一个关键特性在于局部变量和执行状态会在每次调用之间自动保存。 这使得该函数相比使用 self.index 和 self.data 这种实例变量的方式更易编写且更为清晰。 除了会自动创建方法和保存程序状态，当生成器终结时，它们还会自动引发 StopIteration。 这些特性结合在一起，使得创建迭代器能与编写常规函数一样容易。 6.3 生成器表达式 某些简单的生成器可以写成简洁的表达式代码，所用语法类似列表推导式，但外层为圆括号而非方括号。 这种表达式被设计用于生成器将立即被外层函数所使用的情况。 生成器表达式相比完整的生成器更紧凑但较不灵活，相比等效的列表推导式则更为节省内存。 示例: >>> >>> sum(i*i for i in range(10)) # sum of squares 285 >>> xvec = [10, 20, 30] >>> yvec = [7, 5, 3] >>> sum(x*y for x,y in zip(xvec, yvec)) # dot product 260 >>> unique_words = set(word for line in page for word in line.split()) >>> valedictorian = max((student.gpa, student.name) for student in graduates) >>> data = 'golf' >>> list(data[i] for i in range(len(data)-1, -1, -1)) ['f', 'l', 'o', 'g'] Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-21 22:35:14 "},"django/section1/":{"url":"django/section1/","title":"1 环境配置与创建项目","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 安装python注意事项 1.1 windows 1.2 linux&mac 2 创建项目 2.1 创建虚拟环境并创建项目 2.2 配置pycharm 3 创建项目下的app 4 项目结构 5 django约定 环境配置 参考视频 python 3.7以上 env 虚拟环境 django有很多app，如果没有虚拟环境，其中有像contrib下的migrations(配置数据迁移)就全部会装在django的模块下面，如果其它项目也使用django，那么就会被共享，进而数据迁移出现问题。 1 安装python注意事项 1.1 windows windows11下配置path为PYTHON_HOME无法成功，因为有个系统的path：%USERPROFILE%\\AppData\\Local\\Microsoft\\WindowsApps优先级很高，cmd输入python会打开microsoft store 因此在windows11可以用py命令代替python命令。 1.2 linux&mac 使用python3命令即可。 2 创建项目 用windows演示，linux用python3代替py 2.1 创建虚拟环境并创建项目 找到项目想要存储的目录下，输入： D:\\study\\pycharm_saving>py -m venv venv | | | 当前目录下创建一个叫venv的目录 python虚拟环境的模块名字 D:\\study\\pycharm_saving>dir 2022/08/23 17:41 venv D:\\study\\pycharm_saving>dir venv\\ 2022/08/23 17:41 Include 2022/08/23 17:41 Lib 2022/08/23 17:41 84 pyvenv.cfg 2022/08/23 17:41 Scripts D:\\study\\pycharm_saving>.\\venv\\Scripts\\activate.bat 就进入了虚拟环境里： (venv) D:\\study\\pycharm_saving> 可以先查看一下当前虚拟环境中装了哪些模块(pip放在venv\\Scripts目录下)： (venv) D:\\study\\pycharm_saving>pip list Package Version ---------- ------- pip 22.2.1 setuptools 63.2.0 然后我们安装django，配置豆瓣的源安装快一点： (venv) D:\\study\\pycharm_saving>pip install django -i https://pypi.douban.com/simple 然后在当前目录，真正创建项目目录first_project： (venv) D:\\study\\pycharm_saving>django-admin startproject first_project 最后把当前目录下的venv目录放到项目first_project根目录下： (venv) D:\\study\\pycharm_saving\\first_project>dir 2022/08/23 18:05 first_project //项目必要的配置文件 2022/08/23 18:05 691 manage.py //项目入口文件 2022/08/23 17:41 venv 2.2 配置pycharm 按理来说，pycharm会自动配置好，以防万一还是检查一下： Ⅰ python解释器，也就是python执行命令： Ⅱ 移除venv目录，这个目录与项目实际开发的逻辑没有什么关系： Ⅲ django项目配置 3 创建项目下的app 在上一小节，我们将venv移到了项目根目录下，会导致使用django-admin命令报错，因为这个命令中在之前创建虚拟环境时，将虚拟环境的python命令写成了绝对路径，因此一旦移动了venv目录，就会报找不到python命令。 所以此时如果想新建app，就必须得再把venv目录移回之前创建虚拟环境的目录，这里演示是在和项目同级的目录中，然后输入命令进入虚拟环境： D:\\study\\pycharm_saving>.\\venv\\Scripts\\activate.bat 我们再进入项目目录，创建app： //按理来说可以直接输入django-admin，但不知道为什么不行了。。。 (venv) D:\\study\\pycharm_saving\\first_project>..\\venv\\Scripts\\django-admin.exe startapp first_app 查看项目根目录下的文件： (venv) D:\\study\\pycharm_saving\\first_project>dir 2022/08/23 19:47 .idea 2022/08/23 19:39 first_app 2022/08/23 18:28 first_project 2022/08/23 18:05 691 manage.py 2022/08/23 18:28 __pycache__ 此时再将venv目录移到项目根目录中。 可能有人会嫌麻烦，就不想再移动venv目录了，不过因为我们的项目是基于这个虚拟环境的，很多的模块都是安装在这个虚拟环境中的，如果移动项目时忘记这个虚拟环境，就会导致项目无法运行，见仁见智吧... 4 项目结构 cmd输入： >tree /f > 1.txt first_project │ manage.py │ ├─first_app │ │ admin.py │ │ apps.py │ │ models.py │ │ tests.py │ │ views.py │ │ __init__.py │ │ │ └─migrations │ __init__.py │ ├─first_project │ │ asgi.py │ │ settings.py // 全局配置文件 │ │ urls.py // 路由文件 │ │ wsgi.py │ │ __init__.py │ │ │ └─__pycache__ │ settings.cpython-310.pyc │ __init__.cpython-310.pyc │ ├─venv │ │ pyvenv.cfg │ │ │ ├─Include │ ├─Lib │ │ │ └─Scripts │ activate │ activate.bat │ Activate.ps1 │ deactivate.bat │ django-admin.exe │ pip.exe │ pip3.10.exe │ pip3.exe │ python.exe │ pythonw.exe │ sqlformat.exe │ └─__pycache__ manage.cpython-310.pyc 5 django约定 各app之间互相独立，不要互相import。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-25 17:59:58 "},"fastAPI/section1/":{"url":"fastAPI/section1/","title":"1 环境配置与创建项目","keywords":"","body":"环境配置与创建项目 1 创建项目 这次不和django一样创建项目，而是直接使用pycharm将虚拟环境放在项目目录下（django其实也可以这样）。 本来是要进入虚拟环境，然后安装fastapi全家桶的，像下面这样： (venv) D:\\study\\pycharm_saving\\fastapi_project>pip install \"fastapi[all]\" 全家桶包括了 uvicorn，可以将其用作运行代码的服务器。 但pycharm在新建fastapi项目的时候就已经帮我们安装好了，所以就省了功夫。 创建完后的项目结构： fastapi_project │ main.py │ test_main.http │ └─venv │ .gitignore │ pyvenv.cfg │ ├─Lib │ └─site-packages │ └─Scripts activate activate.bat activate.fish activate.ps1 activate.xsh activate_this.py deactivate.bat dotenv.exe pip-3.10.exe pip.exe pip3.10.exe pip3.exe pydoc.bat python.exe pythonw.exe uvicorn.exe watchfiles.exe wheel-3.10.exe wheel.exe wheel3.10.exe wheel3.exe Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-25 18:24:18 "},"fastAPI/section2/":{"url":"fastAPI/section2/","title":"2 启动项目","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 初始文件内容 GET http://127.0.0.1:8000/hello/User 2 启动项目 运行项目 1 初始文件内容 main.py： from fastapi import FastAPI app = FastAPI() @app.get(\"/\") async def root(): return {\"message\": \"Hello World\"} @app.get(\"/hello/{name}\") async def say_hello(name: str): return {\"message\": f\"Hello {name}\"} test_main.http： # Test your FastAPI endpoints GET http://127.0.0.1:8000/ Accept: application/json ### GET http://127.0.0.1:8000/hello/User Accept: application/json 2 启动项目 可以像这样进入虚拟环境输入命令启动项目： D:\\study\\pycharm_saving\\fastapi_project>.\\venv\\Scripts\\activate.bat (venv) D:\\study\\pycharm_saving\\fastapi_project>uvicorn main:app --reload [32mINFO[0m: Will watch for changes in these directories: ['D:\\\\study\\\\pycharm_saving\\\\fastapi_project'] [32mINFO[0m: Uvicorn running on [1mhttp://127.0.0.1:8000[0m (Press CTRL+C to quit) [32mINFO[0m: Started reloader process [[36m[1m19300[0m] using [36m[1mWatchFiles[0m [32mINFO[0m: Started server process [[36m26720[0m] [32mINFO[0m: Waiting for application startup. [32mINFO[0m: Application startup complete. 也可以直接pycharm启动（本质就是输的上方的命令）： 最后，直接访问 http://127.0.0.1:8000 即可 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-25 18:36:38 "}}