{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction python3教程 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-21 13:50:22 "},"chapter1/section1/":{"url":"chapter1/section1/","title":"1.1 基础序列","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 字符串 2 列表 3 代码上手 基础序列 1 字符串 # 次方 -3 ** 2 # 优先级：** > - 被解析成：-(3**2) = -9 # 索引 word = 'Python' word[-1] # 'n' word[42] # 报错 # 切片，省略开始索引时，默认值为 0，省略结束索引时，默认为到字符串的结尾： word[:2] # 'Py' word[4:] # 'on' word[-2:] # 'on' word[4:42] # 'on' word[42:] # '' # 字符串不能修改 word[0] = 'J' # 报错 'J' + word[1:] # 'Jython' # len s = 'supercalifragilisticexpialidocious' len(s) # 34 2 列表 列表：用[]标注，,分隔。 可以包含不同类型的元素，但一般情况下，各个元素的类型相同： squares = [1, 4, 9, 16, 25] # 索引 squares[-1] # 25 # 切片，返回包含请求元素的新列表（浅拷贝） squares[-3:] # [9, 16, 25] letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g'] letters[2:5] = ['C', 'D', 'E'] letters # ['a', 'b', 'C', 'D', 'E', 'f', 'g'] letters[2:5] = [] letters # ['a', 'b', 'f', 'g'] # 合并 squares + [36, 49, 64, 81, 100] # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] # append() 列表结尾添加新元素 squares.append(216) # [1, 4, 9, 16, 25, 216] # len letters = ['a', 'b', 'c', 'd'] len(letters) # 4 # 嵌套列表：创建包含其他列表的列表 a = ['a', 'b', 'c'] n = [1, 2, 3] x = [a, n] x # [['a', 'b', 'c'], [1, 2, 3]] x[0] # ['a', 'b', 'c'] x[0][1] # 'b' 3 代码上手 斐波那契数列： a, b = 0, 1 while a 多重赋值：第1行和第4行，先计算=后面的结果，计算结束后再赋给前面的变量。 缩进区分各语句块。 print()默认换行，可使用end来替换换行符，同时和console.log()一般用法。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-21 16:22:13 "},"chapter1/section2/":{"url":"chapter1/section2/","title":"1.2 流程控制","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 if 2 for 2.1 for、while的else 3 range() 4 pass 5 match 5.1 case中做筛选 5.2 解包赋值与绑定变量 5.3 解构对象 5.4 如何理解 5.5 其他特性 5.5.1 case中的if 5.5.2 仅了解 6 循环的技巧 6.1 循环字典 6.2 循环序列 7 深入条件控制 流程控制 1 if if x 2 for # 创建集合 users = {'Hans': 'active', 'Éléonore': 'inactive', '景太郎': 'active'} # 在新复制的集合上遍历 for user, status in users.copy().items(): if status == 'inactive': del users[user] # 创建一个新集合来存储 active_users = {} for user, status in users.items(): if status == 'active': active_users[user] = status 2.1 for、while的else for 循环中，可迭代对象中的元素全部循环完毕，或 while 循环的条件为假时，执行同一级的else。 for n in range(2, 10): for x in range(2, n): if n % x == 0: print(n, 'equals', x, '*', n//x) break else: print(n, 'is a prime number') 3 range() 可以生成算术序列（整数），返回的是可迭代对象（iterable）。 range(num)：return [0, num) range(begin, end)：return [begin, end) range(begin, end, step)：return [begin, end) 步长为step。 # list()传入可迭代对象，生成一个列表 list(range(-10, -100, -30)) # [-10, -40, -70] # sum()传入可迭代对象，求和 sum(range(4)) # 0 + 1 + 2 + 3 = 6 4 pass pass 语句不执行任何操作。语法上需要一个语句，但程序不实际执行任何动作时，可以使用该语句。 while True: pass # Busy-wait for keyboard interrupt (Ctrl+C) # 创建了一个最小的类： class MyEmptyClass: pass # 用作函数或条件子句的占位符，让开发者聚焦更抽象的层次。 def initlog(*args): pass # Remember to implement this! 5 match 比switch更牛逼的匹配。但不需要break控制。 普通用法不必说，python多了其它种类的匹配： 5.1 case中做筛选 使用 | （或）在一个模式中可以组合多个字面值： case 401 | 403 | 404: return \"Not allowed\" 5.2 解包赋值与绑定变量 # point is an (x, y) tuple 元组 match point: case (0, 0): print(\"Origin\") case (0, y): print(f\"Y={y}\") case (x, 0): print(f\"X={x}\") case (x, y): print(f\"X={x}, Y={y}\") case _: raise ValueError(\"Not a point\") “变量名” _ 被作为 通配符 并必定会匹配成功。 第一个模式有两个字面值，可以看作是上面所示字面值模式的扩展。 但接下来的两个模式结合了一个字面值和一个变量，而变量 绑定 了一个来自目标的值（point）。 第四个模式捕获了两个值，这使得它在概念上类似于解包赋值 (x, y) = point。 5.3 解构对象 class Point: x: int y: int def where_is(point): match point: case Point(x=0, y=0): # 类名后加一个类似于构造器的参数列表，这样做可以把属性放到变量里 print(\"Origin\") case Point(x=0, y=y): print(f\"Y={y}\") case Point(x=x, y=0): print(f\"X={x}\") case Point(): print(\"Somewhere else\") case _: print(\"Not a point\") 总结： 可在 dataclass 等支持属性排序的内置类中使用位置参数。 还可在类中设置 __match_args__ 特殊属性为模式的属性定义指定位置。 如果它被设为 (\"x\", \"y\")，则以下模式均为等价的，并且都把 y 属性绑定到 var 变量： Point(1, var) Point(1, y=var) Point(x=1, y=var) Point(y=var, x=1) 5.4 如何理解 读取模式的推荐方式是将它们看做是：你会在赋值操作左侧放置的内容的扩展形式，以便理解各个变量将会被设置的值。 match 语句赋值： 只有单独的名称：例如上面的 var。 match 语句不会赋值： 带点号的名称：例如 foo.bar； 属性名称：例如上面的 x= 和 y=； 类名称：通过其后的 \"(...)\" 来识别，例如上面的 Point。 因此模式可以任意地嵌套。 例如，如果有一个由点（类实例）组成的短列表，则可使用如下方式进行匹配： match points: case []: print(\"No points\") case [Point(0, 0)]: print(\"The origin\") case [Point(x, y)]: print(f\"Single point {x}, {y}\") case [Point(0, y1), Point(0, y2)]: print(f\"Two on the Y axis at {y1}, {y2}\") case _: print(\"Something else\") 5.5 其他特性 5.5.1 case中的if match point: case Point(x, y) if x == y: print(f\"Y=X at {x}\") case Point(x, y): print(f\"Not on the diagonal\") 5.5.2 仅了解 与解包赋值类似，元组和列表模式具有完全相同的含义，并且实际上能匹配任意序列。 但它们不能匹配迭代器或字符串。 序列模式支持扩展解包操作：[x, y, *rest] 和 (x, y, *rest) 的作用类似于解包赋值。 在 * 之后的名称也可以为 _，因此，(x, y, *_) 可以匹配包含至少两个条目的序列，而不必绑定其余的条目。 映射模式：{\"bandwidth\": b, \"latency\": l} 从字典中捕获 \"bandwidth\" 和 \"latency\" 的值。与序列模式不同，额外的键会被忽略。**rest 等解包操作也支持。但 **_ 是冗余的，不允许使用。 使用 as 关键字可以捕获子模式： case (Point(x1, y1), Point(x2, y2) as p2): ... 将把输入的第二个元素捕获为 p2 (只要输入是包含两个点的序列) 大多数字面值是按相等性比较的，但是单例对象 True, False 和 None 则是按标识号比较的。 模式可以使用命名常量。 这些命名常量必须为带点号的名称以防止它们被解读为捕获变量: from enum import Enum class Color(Enum): RED = 'red' GREEN = 'green' BLUE = 'blue' color = Color(input(\"Enter your choice of 'red', 'blue' or 'green': \")) match color: case Color.RED: print(\"I see red!\") case Color.GREEN: print(\"Grass is green\") case Color.BLUE: print(\"I'm feeling the blues :(\") 6 循环的技巧 6.1 循环字典 在字典中循环时，用 items() 方法可同时取出键和对应的值： knights = {'gallahad': 'the pure', 'robin': 'the brave'} for k, v in knights.items(): print(k, v) # gallahad the pure # robin the brave 6.2 循环序列 在序列中循环时，用 enumerate() 函数可以同时取出位置索引和对应的值： >>> >>> for i, v in enumerate(['tic', 'tac', 'toe']): ... print(i, v) ... 0 tic 1 tac 2 toe 同时循环两个或多个序列时，用 zip() 函数可以将其内的元素一一匹配： >>> >>> questions = ['name', 'quest', 'favorite color'] >>> answers = ['lancelot', 'the holy grail', 'blue'] >>> for q, a in zip(questions, answers): ... print('What is your {0}? It is {1}.'.format(q, a)) ... What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. 逆向循环序列时，先正向定位序列，然后调用 reversed() 函数： >>> >>> for i in reversed(range(1, 10, 2)): ... print(i) ... 9 7 5 3 1 按指定顺序循环序列，可以用 sorted() 函数，在不改动原序列的基础上，返回一个重新的序列： >>> >>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana'] >>> for i in sorted(basket): ... print(i) ... apple apple banana orange orange pear 使用 set() 去除序列中的重复元素。使用 sorted() 加 set() 则按排序后的顺序，循环遍历序列中的唯一元素： >>> >>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana'] >>> for f in sorted(set(basket)): ... print(f) ... apple banana orange pear 一般来说，在循环中修改列表的内容时，创建新列表比较简单，且安全： >>> >>> import math >>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8] >>> filtered_data = [] >>> for value in raw_data: ... if not math.isnan(value): ... filtered_data.append(value) ... >>> filtered_data [56.2, 51.7, 55.3, 52.5, 47.8] 7 深入条件控制 比较运算符 in 和 not in 用于执行确定一个值是否存在（或不存在）于某个容器中的成员检测。 运算符 is 和 is not 用于比较两个对象是否是同一个对象。 所有比较运算符的优先级都一样，且低于任何数值运算符。 比较操作支持链式操作。例如，a 校验 a 是否小于 b，且 b 是否等于 c。 比较操作可以用布尔运算符 and 和 or 组合，并且，比较操作（或其他布尔运算）的结果都可以用 not 取反。 这些操作符的优先级低于比较操作符；not 的优先级最高， or 的优先级最低，因此，A and not B or C 等价于 (A and (not B)) or C。与其他运算符操作一样，此处也可以用圆括号表示想要的组合。 布尔运算符 and 和 or 也称为 短路 运算符：其参数从左至右解析，一旦可以确定结果，解析就会停止。例如，如果 A 和 C 为真，B 为假，那么 A and B and C 不会解析 C。用作普通值而不是布尔值时，短路操作符返回的值通常是最后一个变量。 还可以把比较操作或逻辑表达式的结果赋值给变量，例如： >>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance' >>> non_null = string1 or string2 or string3 >>> non_null 'Trondheim' 注意，Python 与 C 不同，在表达式内部赋值必须显式使用 海象运算符 :=。 这避免了 C 程序中常见的问题：要在表达式中写 == 时，却写成了 =。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-21 17:16:42 "},"chapter1/section3/":{"url":"chapter1/section3/","title":"1.3 函数","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 定义函数 2 定义详解 2.1 默认值参数 2.2 关键字参数 2.2.1 特殊形参 2.3 特殊参数 2.3.1 特殊使用 2.4 任意实参列表 2.5 解包实参列表 2.6 Lambda 表达式 3 编码约定 函数 1 定义函数 def fib(n): \"\"\"Print a Fibonacci series up to n.\"\"\" 函数内的第一条语句是字符串时，该字符串就是文档字符串。 没有 return 语句的函数查看返回值，可使用 print() ，打印值为 None （是一个内置名称）。 2 定义详解 函数定义支持可变数量的参数。 2.1 默认值参数 定义函数，一个必选形参，两个可选形参： def ask_ok(prompt, retries=4, reminder='Please try again!'): while True: ok = input(prompt) if ok in ('y', 'ye', 'yes'): return True if ok in ('n', 'no', 'nop', 'nope'): return False retries = retries - 1 if retries 调用函数： 只给出必选实参：ask_ok('Do you really want to quit?') 给出一个可选实参：ask_ok('OK to overwrite the file?', 2) 给出所有实参：ask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!') 注意： 默认值只计算一次。 i = 5 def f(arg=i): print(arg) i = 6 f() # 5 默认值为列表、字典或类实例等可变对象时，会产生与该规则不同的结果。例如，下面的函数会累积后续调用时传递的参数： def f(a, L=[]): L.append(a) return L print(f(1)) # [1] print(f(2)) # [1, 2] print(f(3)) # [1, 2, 3] 不想在后续调用之间共享默认值时，应以如下方式编写函数： def f(a, L=None): if L is None: L = [] L.append(a) return L 2.2 关键字参数 调用函数的另一种方法称为关键字参数：f(key=value) 关键字形参也叫作命名形参。 def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'): print(\"-- This parrot wouldn't\", action, end=' ') print(\"if you put\", voltage, \"volts through it.\") print(\"-- Lovely plumage, the\", type) print(\"-- It's\", state, \"!\") # 如此调用： parrot(1000) # 1 positional argument parrot(voltage=1000) # 1 keyword argument parrot(voltage=1000000, action='VOOOOOM') # 2 keyword arguments parrot(action='VOOOOOM', voltage=1000000) # 2 keyword arguments parrot('a million', 'bereft of life', 'jump') # 3 positional arguments parrot('a thousand', state='pushing up the daisies') # 1 positional, 1 keyword 下面这些调用方式无效： parrot() # required argument missing parrot(voltage=5.0, 'dead') # non-keyword argument after a keyword argument parrot(110, voltage=220) # duplicate value for the same argument parrot(actor='John Cleese') # unknown keyword argument 总结 只要必选实参用了关键字参数，后面的可选参数必须也用关键字参数。 但如果必选实参没用关键字参数，后面可选参数可以选择性使用关键字参数， 但如果后面可选参数不使用关键字参数，则是按照位置顺序传参。 2.2.1 特殊形参 最后一个形参为 **name 形式时，接收一个字典（详见 映射类型 --- dict），该字典包含与函数中已定义形参对应之外的所有关键字参数。 **name 形参可以与 *name 形参（下下小节介绍）组合使用（name 必须在 *name 前面）， *name 形参接收一个 元组，该元组包含形参列表之外的位置参数。 例如，可以定义下面这样的函数： def cheeseshop(kind, *arguments, **keywords): print(\"-- Do you have any\", kind, \"?\") print(\"-- I'm sorry, we're all out of\", kind) for arg in arguments: print(arg) print(\"-\" * 40) for kw in keywords: print(kw, \":\", keywords[kw]) 调用该函数： cheeseshop(\"Limburger\", \"It's very runny, sir.\", \"It's really very, VERY runny, sir.\", shopkeeper=\"Michael Palin\", client=\"John Cleese\", sketch=\"Cheese Shop Sketch\") # 输出结果如下： -- Do you have any Limburger ? -- I'm sorry, we're all out of Limburger It's very runny, sir. It's really very, VERY runny, sir. ---------------------------------------- shopkeeper : Michael Palin client : John Cleese sketch : Cheese Shop Sketch 注意，关键字参数在输出结果中的顺序与调用函数时的顺序一致。 2.3 特殊参数 为了让代码易读、高效，通过在函数定义添加 / 和 * 限制参数的传递方式。 / 和 *是可选的。 def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2): ----------- ---------- ---------- | | | 位置 位置或关键字 关键字 例子： def standard_arg(arg): # 无限制 print(arg) def pos_only_arg(arg, /): # 仅限位置参数 print(arg) def kwd_only_arg(*, arg): # 仅限关键字参数 print(arg) def combined_example(arg, /, pos_or_kwd): # / 后可以是 位置或关键字 或 仅限关键字 形参。 print(pos_only, pos_or_kwd) def combined_example(pos_or_kwd, *, kwd_only): # * 前可以是 位置或关键字 或 仅限位置 形参。 print(pos_or_kwd, kwd_only) def combined_example(pos_only, /, standard, *, kwd_only): print(pos_only, standard, kwd_only) 2.3.1 特殊使用 # kwds 把 name 当作键，因此，可能与位置参数 name 产生潜在冲突： def foo(name, **kwds): return 'name' in kwds foo(1, **{'name': 2}) # 报错，不可能返回 True，因为关键字 'name' 总与第一个形参绑定，即'name' = 1, kwds中'name' = 2，1!=2 # 加上 / （仅限位置参数），此时，函数定义把 name 当作位置参数，'name' 也可以作为关键字参数的键： def foo(name, /, **kwds): return 'name' in kwds foo(1, **{'name': 2}) # true 判断为在kds是否存在有'name'这个键了。 换句话说，函数定义中的name是个形参，而return后面的name是个字符串，两者已经没有绑定在一起，因此字符串可以在 **kwds 中使用，而不产生歧义。 2.4 任意实参列表 *args 形参后的任何形式参数只能是仅限关键字参数， def concat(*args, sep=\"/\"): return sep.join(args) concat(\"earth\", \"mars\", \"venus\") # 'earth/mars/venus' concat(\"earth\", \"mars\", \"venus\", sep=\".\") # 'earth.mars.venus' 2.5 解包实参列表 *：解包列表 list(range(3, 6)) # [3, 4, 5] args = [3, 6] list(range(*args)) # [3, 4, 5] 用 * 操作符把实参从列表或元组解包成两个独立的 start 和 stop 实参： **：解包字典 即json或map格式的数据 def parrot(voltage, state='a stiff', action='voom'): print(\"-- This parrot wouldn't\", action, end=' ') print(\"if you put\", voltage, \"volts through it.\", end=' ') print(\"E's\", state, \"!\") d = {\"voltage\": \"four million\", \"state\": \"bleedin' demised\", \"action\": \"VOOM\"} parrot(**d) # This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised ! 2.6 Lambda 表达式 在语法上，匿名函数只能是单个表达式。 用 lambda 表达式返回函数： def make_incrementor(n): return lambda x: x + n f = make_incrementor(42) f(0) # 42 f(1) # 43 匿名函数用作传递的实参： pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')] pairs.sort(key=lambda pair: pair[1]) pairs # [(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')] 3 编码约定 缩进，用 4 个空格 用空行分隔函数和类，及函数内较大的代码块。 最好把注释放到单独一行。 使用文档字符串。 命名类用 UpperCamelCase， 命名函数与方法用 lowercase_with_underscores。 命名方法中第一个参数总是用 self Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-21 16:53:25 "},"chapter1/section4/":{"url":"chapter1/section4/","title":"1.4 数据结构","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 列表 1.1 列表推导式 1.2 del命令 2 序列：元组 2.1 列表与元组的区别 2.2 创建0元组和1元组 2.3 元组打包和序列解包 3 集合 3.1 集合推导式 4 字典 4.1 dict() 4.2 字典推导式 5 序列之间的比较 数据结构 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）； 可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。 1 列表 方法 解释 append(x) 在列表末尾添加一个元素，相当于 a[len(a):] = [x] 。 extend(iterable) 用可迭代对象的元素扩展列表。相当于 a[len(a):] = iterable 。 insert(i, x) 在指定位置插入元素。第一个参数是插入元素的索引，因此，a.insert(0, x) 在列表开头插入元素， a.insert(len(a), x) 等同于 a.append(x) 。 remove(x) 从列表中删除第一个值为 x 的元素。未找到指定元素时，触发 ValueError 异常。 pop([i]) 删除列表中指定位置的元素，并返回被删除的元素。未指定位置时，a.pop() 删除并返回列表的最后一个元素。（方法签名中 i 两边的方括号表示该参数是可选的，不是要求输入方括号。这种表示法常见于 Python 参考库）。 clear() 删除列表里的所有元素，相当于 del a[:] 。 index(x[, start[, end]]) 返回列表中第一个值为 x 的元素的零基索引。未找到指定元素时，触发 ValueError 异常。可选参数 start 和 end 是切片符号，用于将搜索限制为列表的特定子序列。返回的索引是相对于整个序列的开始计算的，而不是 start 参数。 count(x) 返回列表中元素 x 出现的次数。 sort(*, key=None, reverse=False) 就地排序列表中的元素（要了解自定义排序参数，详见 sorted()）。 reverse() 翻转列表中的元素。 copy() 返回列表的浅拷贝。相当于 a[:] 。 fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana'] >>> fruits.count('apple') # 2 >>> fruits.count('tangerine') # 0 >>> fruits.index('banana') # 3 >>> fruits.index('banana', 4) # 6 >>> fruits.reverse() >>> fruits # ['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange'] >>> fruits.append('grape') >>> fruits # ['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape'] >>> fruits.sort() >>> fruits # ['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear'] >>> fruits.pop() # 'pear' 1.1 列表推导式 常见的用法为， 对序列或可迭代对象中的每个元素应用某种操作， 用生成的结果创建新的列表； 或用满足特定条件的元素创建子序列。 这种写法更简洁、易读。（？？？） 列表推导式的[]内包含以下内容： 一个表达式，后面是零个或多个 for 或 if 子句。 结果是由表达式依据 for 和 if 子句求值计算而得出一个新列表。 例1，创建平方值的列表： # 列表推导式 squares = [x**2 for x in range(10)] #等价于 squares = [] for x in range(10): squares.append(x**2) 例2，将两个列表中不相等的元素组合起来： [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y] #等价于 combs = [] for x in [1,2,3]: for y in [3,1,4]: if x != y: combs.append((x, y)) 例3，转置行列（嵌套列表推导式）： matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], ] [[row[i] for row in matrix] for i in range(4)] # [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]] # 等价于 transposed = [] for i in range(4): transposed.append([row[i] for row in matrix]) # 实际应用中，最好用内置函数替代复杂的流程语句。 list(zip(*matrix)) 1.2 del命令 del 语句按索引，而不是值从列表中移除元素。 >>> a = [-1, 1, 66.25, 333, 333, 1234.5] >>> del a[0] >>> a # [1, 66.25, 333, 333, 1234.5] >>> del a[2:4] >>> a # [1, 66.25, 1234.5] >>> del a[:] >>> a # [] >>> del a # 删除整个变量，再引用 a 就会报错（直到为它赋与另一个值） 2 序列：元组 序列： 字符串 列表 元组 元组由多个用,隔开的值组成， >>> t = 12345, 54321, 'hello!' >>> t[0] # 12345 >>> t # (12345, 54321, 'hello!') >>> u = t, (1, 2, 3, 4, 5) >>> u # ((12345, 54321, 'hello!'), (1, 2, 3, 4, 5)) >>> v = ([1, 2, 3], [3, 2, 1]) >>> v # ([1, 2, 3], [3, 2, 1]) 输入时，圆括号可有可无，不过经常是必须的（如果元组是更大的表达式的一部分）。 输出时，元组都要由圆括号标注，这样才能正确地解释嵌套元组。 不允许为元组中的单个元素赋值，当然，可以创建含列表等可变对象的元组。 2.1 列表与元组的区别 列表： mutable （可变的），列表元素一般为同质类型，可迭代访问。 元组： immutable （不可变的），一般可包含异质元素序列，通过解包（见本节下文）或索引访问（如果是 namedtuples，可以属性访问）。 因此，元组与列表虽然很像，但使用场景不同，用途也不同。 2.2 创建0元组和1元组 >>> empty = () # 0元组 >>> singleton = 'hello', # 1元组，结尾有个逗号 >>> len(empty) # 0 >>> len(singleton) # 1 >>> singleton # ('hello',) 2.3 元组打包和序列解包 t = 12345, 54321, 'hello!' # 元组打包 x, y, z = t # 序列解包，左侧变量与右侧序列元素的数量应相等。 多重赋值其实只是元组打包和序列解包的组合。 3 集合 集合是由不重复元素组成的无序容器。基本用法包括： 成员检测、 消除重复元素。 集合对象支持合集、交集、差集、对称差分等数学运算。 创建集合只能用 set() ！ 虽然{}也可以，但它不能用在创建空集合的时候，因为那是创建空字典，因此创建集合统一使用set()。 >>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'} 或者 >>> basket = set(('apple', 'orange', 'apple', 'pear', 'orange', 'banana')) #只能传入一个参数，可以是list,tuple等 类型 >>> print(basket) # {'orange', 'banana', 'pear', 'apple'} >>> 'orange' in basket # True >>> 'crabgrass' in basket # False >>> # Demonstrate set operations on unique letters from two words ... >>> a = set('abracadabra') >>> b = set('alacazam') >>> a # {'a', 'r', 'b', 'c', 'd'} >>> a - b # 差集 {'r', 'd', 'b'} >>> a | b # 并集 {'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'} >>> a & b # 交集 {'a', 'c'} >>> a ^ b # 反交集 {'r', 'd', 'b', 'm', 'z', 'l'} 3.1 集合推导式 >>> a = {x for x in 'abracadabra' if x not in 'abc'} >>> a # {'r', 'd'} 4 字典 其他语言可能把字典称为 联合内存 或 联合数组。其实就是map。 与以连续整数为索引的序列不同，字典以 关键字 为索引，关键字通常是： 字符串， 或数字， 或只包含字符串、数字、元组的元组。 也可以是其他任意不可变类型。 但如果元组直接或间接地包含了可变对象，就不能用作关键字。 创建字典： 空的 {} 用于创建空字典。 在{}里输入,分隔的键值对，这也是字典的输出方式。 使用字典： 用 del 可以删除键值对。 对字典执行 list(d) 操作，返回该字典中所有键的列表，按插入次序排列 排序，请使用 sorted(d)。 检查字典里是否存在某个键，使用关键字 in。 例子： >>> tel = {'jack': 4098, 'sape': 4139} >>> tel['guido'] = 4127 >>> tel # {'jack': 4098, 'sape': 4139, 'guido': 4127} >>> tel['jack'] # 4098 >>> del tel['sape'] >>> tel['irv'] = 4127 >>> tel # {'jack': 4098, 'guido': 4127, 'irv': 4127} >>> list(tel) # ['jack', 'guido', 'irv'] >>> sorted(tel) # ['guido', 'irv', 'jack'] >>> 'guido' in tel # True >>> 'jack' not in tel # False 4.1 dict() dict() 构造函数可以直接用键值对序列创建字典： >>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)]) # {'sape': 4139, 'guido': 4127, 'jack': 4098} 关键字是比较简单的字符串时，直接用关键字参数指定键值对更便捷： >>> dict(sape=4139, guido=4127, jack=4098) # {'sape': 4139, 'guido': 4127, 'jack': 4098} 4.2 字典推导式 >>> {x: x**2 for x in (2, 4, 6)} # {2: 4, 4: 16, 6: 36} 5 序列之间的比较 序列对象可以与相同序列类型的其他对象比较。这种比较使用 字典式 顺序： 首先，比较前两个对应元素，如果不相等，则可确定比较结果；如果相等，则比较之后的两个元素，以此类推，直到其中一个序列结束。 如果要比较的两个元素本身是相同类型的序列，则递归地执行字典式顺序比较。 如果两个序列中所有的对应元素都相等，则两个序列相等。 如果一个序列是另一个的初始子序列，则较短的序列可被视为较小（较少）的序列。 对于字符串来说，字典式顺序使用 Unicode 码位序号排序单个字符。下面列出了一些比较相同类型序列的例子： (1, 2, 3) 注意，对不同类型的对象来说，只要待比较的对象提供了合适的比较方法，就可以使用 进行比较。例如，混合数值类型通过数值进行比较，所以，0 等于 0.0，等等。否则，解释器不会随便给出一个对比结果，而是触发 TypeError 异常。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-21 17:20:12 "}}